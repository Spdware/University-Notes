# Synchronization in a Distributed System: an Introduction
The problem of synchronizing concurrent activities arises also in non-distributed systems
However, distribution complicates matters:
- Absence of a global physical clock
- Absence of globally shared memory
- Partial failures
In these lectures, we study distributed algorithms for:
- Synchronizing physical clocks
- Simulating time using logical clocks & preserving event ordering
- Mutual exclusion
- Leader election
- Collecting global state & termination detection
- Distributed transactions
- Detecting distributed deadlocks
Time plays a fundamental role in many applications:
- Execute a given action at a given time
- Time stamping objects/data/messages enables reconstruction of event ordering
	- File versioning
	- Distributed debugging
	- Security algorithms

![](https://i.imgur.com/8iys5K0.png)

### Time
Up to 1940 time was measured astronomically: 1 second = 1/86400th of a mean solar day (the mean time interval between two consecutive transits of the sun), but the problem is that Earth is slowing down. Since 1948, time is measured physically: 1 second = 9,192,631,770 transitions of an atom of Cesium 133.  
# Synchronizing physical clocks
The PC use the GPS to synchronize clocks. In general clocks have a drifts, the clocks in pc doesn't measure time but it is like a metronome. You can do synchronization against the global clock or between nodes clocks. To do so you can go back(bad as all the algorithm assume advancing, instead you slow down the faster till the clocks are synchronzed) or you can go forward with one of the clock time. 
### GPS
![](https://i.imgur.com/0J4Bfjs.png)

We need the satellite to not skew in time, we connect them before leaving to avoid skewing. Usually they also use atomic clocks. The hypothesis is that the device clock is so synchronized with the satellite clock that the distance delay can be ignored. We have three incognita: x position, y position and time. We need at least three satellite to determine the position and the perfect time of the receiver. This is what you want. The precision is so high that the error is caused in the HW line length or delay. 
### Simple algorithms: Cristian’s (1989)
Problems with GPS is that it cost a lot and work only in open space. 
The Cristian's algorithm only leverage the network: it uses the network time to synchronize the nodes. Usually it is used the server time clock with a minimum delay to take in count the time needed for the synchronization/message travel time. The assumption is that the network is omogeneous(time to go = time to come back). 

![](https://i.imgur.com/zdURTad.png)

### Simple algorithms: Berkeley (1989)
There is an active time server that ask periodically to the nodes what time is it and then compute an average and gives back the adjustement

![](https://i.imgur.com/oAnDMJv.png)

### Network Time Protocol (NTP)
All the machines on a large network are connected in a tree way and each machine ask the father for the perfect time. The machine on the root have it. When you start a machine you add the information of the NTP network that is in the same subnetwork/same country and depending on the network NTP use different protocol: in LAN NTP periodically send time update otherwise it operate similar to Cristian's but operate simmetrically: if a machine want ot synchronize with another one it send a message. This message contain the starting time(based on its own clock). The receiver use its own clock and answer to the message after some time. This operation is repeated a second time and then the host can calculate the time knowing the 4 number:

![](https://i.imgur.com/F9JcyM1.png)

- $T_{i-2} = T_{i-3} + t + o$ and $T_i = T_{i-1} + t’ – o$
- Total transmission time: $d_i = t + t’ = T_{i-2} – T_{i-3} +T_i – T_{i-1}$
- $o_i = (T_{i-2} – T_{i-3} + T_{i-1} – T_i)/2$
- o = oi + (t’-t)/2
- $o_i – d_i/2 = o_i + (t’-t)/2 – t’ \le o \le o_i + (t’-t)/2 + t = o_i + d_i/2$
Thus $o_i$ is an estimate of the offset and $d_i$ is a measure of the accuracy of this estimate. We continue until the estimate is good enough. In practice NTP allows to synchronize in networks as large as the internet clocks with error to $10^{15}$ milliseconds. 
# Logical time: Scalar clocks and Vector clocks
Usually the order of happening is what is important in application for correctness. We care if two events are in causal order or sequence order. We want to respect the causal order(typically). If there is no intercation is not necessary to keep the event in synch as there isn't an interaction. 
### Scalar CLock
Events: things that happens in the distributed system and it is relevant for it
Let define the happens-before relationship $e\rightarrow e’$, as follows:
- If event e and e' occur in the same process and e occur before e' then e happens before e'.
- Sending of a message: if e is the sender of a message and e' is the receiver of the same message and e and e' happens in different process, e must happen before e'. Every type of communication require some time and order for emitting/receiving the communication. 
- This relation must be transitive
This relationship define a partial order between events as it cannot say anything about uncorrelated events/events that aren't communicating. If there is no interaction between events there can't be causality. The happens before relationship is the best approximation of causal relationship.

![](https://i.imgur.com/FyhCBio.png)

The only thing we can say is that if two events are in the happens before relationship one has a Lamport clock smaller than the other. If you order events in Lamport time you are assuring that the happens before relation it respected. Lamport clock define the global order. The acknowledgment are fundamental as they permit to know what message I can receive from each process as they also contain the Lamport clock. Message are FIFO. You have to acknowledge everyone(when you receive one you have to wait for each node to acknowlegde). Message and acknowledge MUST be in broadcast.A message is delivered to the application **only when it is at the highest in the queue** and **all its acks have been received**
### Vector Clocks

