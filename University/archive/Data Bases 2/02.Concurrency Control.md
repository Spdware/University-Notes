The Concurrency Control System manages the simultaneous execution of transactions,avoids the insurgence of anomalies while ensuring performance.
One of the advantages of concurrency is to exploit the parallelism to maximise transactions per second(TPS).
The problems of concurrency is that the transactions have to be executed in parallel as they were done in sequence.
Concurrency is fundamental as DB need to execute tens or hundreds of transactions per second and naturally they cannot be done serially, but the concurrent execution may cause anomalies $\rightarrow$ concurrency needs to be controlled

![|500](https://i.imgur.com/j9Vokj9.png)

### Execution with Lost Update
An update is applied from a state that ignores a preceding update, which is lost
D = 100
1 $T_1$: r(D $\rightarrow$ x)
2 $T_1$: x = x + 3
3     _$T_2$: r(D $\rightarrow$ y)_
4     _$T_2$: y = y + 6_
5 $T_1$: w(x $\rightarrow$ D) D = 103 
6     _$T_2$: w(y $\rightarrow$ D) D = 106 !_
Note: this anomaly does not depend merely on $T_2$ overwriting the value produced by $T_1$
- $w_1$(D), $w_2$(D) is ok (serial)
- $r_1$(D), $w_1$(D), $w_2$(D) is ok too (serial)
-  $r_1$(D), $r_2$(D), $w_1$(D), $w_2$(D) is not ok: inconsistent updates from the same 
### Dirty Read
An uncommitted value is used to update the data
D = 100
1 $T_1$: r(D $\rightarrow$ x)
2 $T_1$: x = x + 3
3 $T_1$: w(x $\rightarrow$ D) D = 103 
4 $T_2$: r(D $\rightarrow$ y) this read is “dirty” (uncommitted value) 
5 $T_1$: rollback
6 $T_2$: y = y + 6
7 $T_2$: w(y $\rightarrow$ D) D = 109 !
### Non-Repeatable Read
Someone else updates a previously read value
D = 100
1 $T_1$: r(D  $\rightarrow$ x)
2 $T_2$: r(D  $\rightarrow$ y)
3 $T_2$: y = y + 6
4 $T_2$: w(y  $\rightarrow$ D) D = 106
5 $T_1$: r(D  $\rightarrow$ z) z <> x !
###  Phantom update
Someone else updates data that contributes to a previously valid constraint
Constraint: A+B+C=100, A=50, B=30, C=20
$T_1$: r(A $\rightarrow$ x), r(B $\rightarrow$ y)……
$T_2$: r(B $\rightarrow$ s), r(C $\rightarrow$ t)
$T_2$: s = s + 10, t = t – 10 
$T_2$: w(s $\rightarrow$ B), w(t $\rightarrow$ C) (now B=40, C=10, A+B+C=100) 
$T_1$: r(C $\rightarrow$ z) (but, for $T_1$, x+y+z = A+B+C = 90!)
So for $T_1$ it is as if “somebody else” had updated the value of the sum
But for $T_2$ the update is perfectly legal (does not change the value of the sum)
### Phantom Insert
Someone else inserts data that contributes to a previously read datum
$T_1$: C=AVG(B: A=1) 
$T_2$: Insert (A=1,B=2
$T_1$: C=AVG(B: A=1) 
Note: this anomaly does not depend on data already present in the DB when $T_1$ executes, but on a “phantom” tuple that is inserted by “someone else” and satisfies the conditions of a previous query of $T_1$
# Concurrency Theory vs System Implementation
Model: an abstraction of a system, object or process, which purposely disregards details to simplify the investigation of relevant properties
Concurrency Theory builds upon a model of transactions and concurrency control principles that helps understanding real systems
Real systems exploit implementation level mechanisms  (locks, snapshots) which help achieve some of the desirable properties postulated by the theory:
- Do not look for a view or conflict serializability checker in your DBMS
- Look instead for lock tables, lock types, lock granting rules, snapshots, etc..
- Understand how the implementation mechanisms ensure properties modelled by the Concurrency Theory
# Transactions, Operations, Schedules
Operation: a read or write of a specific datum by a specific transaction
Schedule: a sequence of operations performed by concurrent transactions __that respects the order of operations of each transaction__
# Schedules

![|500](https://i.imgur.com/z0O8MdD.png)

We have $N_S$ serial schedules for n transactions and $N_D$ distinct transactions.
$$N_S=n!,N_D=\frac{(\sum_{i=1}^n k_i)!}{\prod_{i=1}^{n}(k_i!)}$$
# Principles of Concurrency Control
Goal: to reject schedules that cause anomalies
Scheduler: a component that accepts or rejects the  operations requested by the transactions
Serial schedule: a schedule in which the actions of each transaction occur in a contiguous sequence
Serializable schedule: a schedule that leaves the database in the same state as some serial schedule of the same transactions. Commonly accepted as a notion of schedule correctness. Requires a notion of schedule equivalence to identify classes of schedules that ensure serializability
Assumption:
- We initially assume that transactions are observed “a- posteriori” and limited to those that have committed (commit-projection), and we decide whether the observed schedule is admissible 
- In practice (and in contrast), schedulers must make decisions while transactions are running
DB need to make decision when the commit is done.

![|500](https://i.imgur.com/YdYFiZD.png)

### View Serializability
Preliminary definitions:
- $r_i$(x) reads-from $w_j$(x) in a schedule S when $w_j$(x) precedes $r_i$(x) and there is no $w_k$(x) in S between $r_i$(x) and $w_j$(x)
- $w_i$(x) in a schedule S is a final write if it is the last write on x that occurs in S
Given two schedule we want to decide if they are view-equivalent($S_i\approx_VS_j$):
1. If we have two transaction that works on the same resource they must have the same read-from relationship
2. They have the same operations
3. the same final writes
A schedule is view-serializable if it is view-equivalent to a serial schedule of the same transactions. The class of view-serializable schedules is named VSR.
Mnemonically: S is view-serializable if
1. every read operation sees the same values and
2. the final value of each object is written by the same transaction
	- as if the transactions were executed serially in some order
The reads-from relationship $r_i$(x) reads-from $w_j$(x) in a schedule S assumes that $r_i$(x) reads the value written by $w_j$(x) independently of the time at which the commit of $T_j$ occurs. In other words the value written by $w_j$(x) could be uncommitted when $r_i$(x) reads it but we are sure (by definition of commit projection) that it will be committed
The check is linear. The complexitiy comes from the fact we have a factorial number of transaction we have to scan to determine if two transactions are view-serializable $\rightarrow$ it is a NP-Complete Problem. So we look for a stricter definition that is easier to check.
### Conflict-serializability
A conflict is a situation where in a schedule I have two operations by two transaction in which at least one is a write on the same value of the other.Two operations $o_i$ and $o_j$ ($i \neq j$) are in conflict if
they address the same resource and at least one of them is a write
-  read-write conflicts ( r-w or w-r )
-  write-write conflicts ( w-w ) 
Two schedules are conflict-equivalent ($S_i \approx_C S_j$) if :
- $S_i$ and $S_j$ contain the same operations and in all the conflicting pairs the transactions occur in the same order
- A schedule is conflict-serializable iff it is conflict-equivalent to a serial schedule of the same transactions
- The class of conflict-serializable schedules is named CSR
CSR $\subset$ VSR: all conflict-serializable schedule are also view-serializable, but is not true the contrary.
Conflict-equivalence implies view-equivalence therefore conflict-serializability implies view-serializability.
### Testing Conflict-Serializability
It is done with a conflict graph: a simple directed graph with as many node as transactions and an ark for every conflict in the schedule(start from the first transaction and it arrive at the second transacction). This graph is CSR only if this graph is acyclic. It is done with $O(n^2)$ or $O(n^3)$ and for us it is acceptable as we are arriving from a NP-problem. The ark are referred to every conflict occurs on a resource even if the operations aren't consecutive.
We can prove that being in CSR it implies an acyclic conflict-graph and vice-versa.
### Concurrency Control in Practice
The assumption of CSR and VSR is that they are working on what will be committed to the database, it is as we have everything beforehand that is unrealistic. Not feasible to do it at every operation. We want to find a clever way to not waste so much time. 
The interpretation of the schedule is a posteriori view. From now we will use an arrival sequence(sequence of request by transactions). From a notation point of view it has an history, it seem the same thing but we will distinguish it from the context. The idea is that the arrival sequence maps the arrival sequence in an history of operations. 
Implemented it online with two approaches:
- Pessimistic
	 - Based on locks, i.e., resource access control. Prevents the worst case scenario but putting a toll on the system(requiring waiting the end of an operation, risk of deadlock)
	- If a resource is taken, make the requester wait or pre-empt the holder
-  Optimistic: implies much less waiting and killing of transaction. based on "age" of transaction and on it decide if holding or killing the transaction. 
	- Based on timestamps and versions
	- Serve as many requests as possible, possibly using out-of-date versions of the data
Commercial systems take the best of both worlds.
### Locking
Approach traditionally most common. The idea is to have a lock of different type:
- Read lock or r_lock: we only want to read a resource, it not block the reading of the resource. It is a shared lock. At the end of the operation I have to unlock the resource.
- Write lock or w_lock: we acquire a resource to write on it. It is an exclusive lock as I don't want anybody to access the resource while I am using it. At the end I have to unlock the resource
The access to exclusively locked resource usually is putted on hold until the resource is free. The arrival sequence will not coincide with the history as the locks impose some operations to be delayed.
If a transaction want to read and then write and object it can acquire a w_lock already when reading or acquire a r_lock and upgrade it to a w_lock(naturally if it isn't shared with someone else).
State of an object:
- free
- r-locked(locked by one or more reader)
- w-locked(locked by a writer)
The lock manager receives requests from the transactions and grants resources according to the conflict table(in the table is assumed the request is done by a different transaction, if the lock request is granted the resource is acquired and when a lock is executed the resource become available): 

![|400](https://i.imgur.com/i3p1lHT.png)


